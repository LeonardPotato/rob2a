
// virkar ef commentid er tekid ut nedst.

#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  rightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port8,           armMotor,      tmotorVex269, openLoop)
#pragma config(Motor,  port9,           clawMotor,     tmotorNormal, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Move Forward and Backward - 393 Motors
This program instructs your robot to move forward at half power for 1000 encoder counts, then reverse
at half power for 1000 encoder counts. There is a two second pause at the beginning of the program.

Robot Model(s): Modified Squarebot

[I/O Port]					[Name]							[Type]								[Description]
Motor Port 1				rightMotor					393 Motor							Right side motor
Motor Port 10				leftMotor						393 Motor							Left side motor, Reversed
I2C_1								rightIEM						Integrated Encoder		Encoder mounted on rightMotor
I2C_2								leftIEM							Integrated Encoder		Encoted mounted on leftMotor
----------------------------------------------------------------------------------------------------*/
const int BASE_DIST = 545;
const float BASE_TURN = 3.1904;  //33.5/10.5
int power = 64;
bool turn_lr[14]={true,false,false,true,true,false,true,true,false,true,true,false,false,true};

void drive(int dist,int b_f ){
	while(abs(nMotorEncoder[rightMotor])< dist)		// Creates an infinite loop, since "true" always evaluates to true
	{

		if(abs(nMotorEncoder[rightMotor]) == abs(nMotorEncoder[leftMotor])) // If rightEncoder has counted the same amount as leftEncoder:
		{
			// Move Forward
			motor[rightMotor] = power*b_f;		    // Right Motor is run at power level 80
			motor[leftMotor]  = power*b_f;		    // Left Motor is run at power level 80
		}
		else if(abs(nMotorEncoder[rightMotor]) > abs(nMotorEncoder[leftMotor]))	// If rightEncoder has counted more encoder counts
		{
			// Turn slightly right
			motor[rightMotor] = (power-20)*b_f;		    // Right Motor is run at power level 60
			motor[leftMotor]  = power*b_f;		    // Left Motor is run at power level 80
		}
		else	// Only runs if leftEncoder has counted more encoder counts
		{
			// Turn slightly left
			motor[rightMotor] = power*b_f;		    // Right Motor is run at power level 80
			motor[leftMotor]  = (power-20)*b_f;		    // Left Motor is run at power level 60
		}

	}
}
void reset_encoder(){
	nMotorEncoder[rightMotor] = 0;
	nMotorEncoder[leftMotor] = 0;
}
void stop_motors(){
	motor[rightMotor] = 0;
	motor[leftMotor]  = 0;
	wait1Msec(500);
}

void turn(int deg,bool r_l){
	while(deg*BASE_TURN > (abs(nMotorEncoder[rightMotor]))){
		if(r_l){
			motor[rightMotor] = -60;
			motor[leftMotor]  = 60;
		}
		else{
			motor[rightMotor] = 60;
			motor[leftMotor]  = -60;
		}

	}

}


task main
{
	int joy_x;            // will hold the X value of the analog stick (choices below)
	int joy_y;            // will hold the Y value of the analog stick (choices below)
	int threshold = 10;   // helps to eliminate 'noise' from a joystick that isn't perfectly at (0,0)

	while(1 == 1)
	{
		joy_x = vexRT[Ch1];   // This is the RIGHT analog stick.  For LEFT, change 'Ch1' to 'Ch4'.
		joy_y = vexRT[Ch2];   // This is the RIGHT analog stick.  For LEFT, change 'Ch2' to 'Ch3'.

		// Forward, and swing turns: (both abs(X) and abs(Y) are above the threshold, and Y is POSITIVE)
		if((abs(joy_x) > threshold) && (abs(joy_y) > threshold) && (joy_y > 0))
		{
			motor[leftMotor]  = (joy_y + joy_x)/2;
			motor[rightMotor] = (joy_y - joy_x)/2;
		}
		// Backwards and swing turns: (both abs(X) and abs(Y) are above the threshold, and Y is NEGATIVE)
		else if((abs(joy_x) > threshold) && (abs(joy_y) > threshold) && (joy_y < 0))
		{
			motor[leftMotor]  = (joy_y - joy_x)/2;
			motor[rightMotor] = (joy_y + joy_x)/2;
		}
		// Turning in place: (abs(X) is above the threshold, abs(Y) is below the threshold)
		else if((abs(joy_x) > threshold) && (abs(joy_y) < threshold))
		{
			motor[leftMotor]  = joy_x;
			motor[rightMotor] = (-1 * joy_x);
		}
		// Standing still: (both abs(X) and abs(Y) are below the threshold)
		else
		{
			motor[leftMotor]  = 0;
			motor[rightMotor] = 0;
		}

		if(vexRT[Btn6U] == 1)
		{
			motor[armMotor] = 40;
		}
		else if(vexRT[Btn6D]==1)
		{
			motor[armMotor] = -40;
		}
		else{
			motor[armMotor]=0;
		}
		
		if(vexRT[Btn5U] == 1)
		{
			motor[clawMotor] = 40;
		}
		else if(vexRT[Btn5D]==1)
		{
			motor[clawMotor] = -40;
		}
		else{
			motor[clawMotor]=0;
		}
	}
}


	/*---------------------------*/
	/*reset_encoder();
	for(int i = 1;i<14;i++){
	reset_encoder();
	drive(BASE_DIST,1);
	stop_motors();
	reset_encoder();
	power=64;
	wait1Msec(1000);
	turn(90, turn_lr[i-1]);*/
//}
/*wait1Msec(2000);
for(int i = 1;i<6;i++){
reset_encoder();
drive(BASE_DIST*i,1);
stop_motors();
reset_encoder();
drive(BASE_DIST*i,-1);
stop_motors();
power=64;
wait1Msec(1000);
//}*/
